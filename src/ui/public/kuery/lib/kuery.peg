/*
 * Kuery parser
 */

/*
 * Initialization block
 */
{
 function ltoo (literal) {
  return {type: 'literal', value: literal}
 }

 function simpleLocation (location) {
  // Returns an object representing the position of the function within the expression,
  // demarcated by the position of its first character and last character. We calculate these values
  // using the offset because the expression could span multiple lines, and we don't want to deal
  // with column and line values.
  return {
   min: location.start.offset,
   max: location.end.offset
  }
 }

 function buildAndQuery(children, location, text, serializeStyle) {
  return {
    type: 'function',
    function: 'and',
    arguments: children,
    location: simpleLocation(location),
    text: text,
    serializeStyle: serializeStyle,
  }
 }

 function buildNotQuery(children, location, text, serializeStyle) {
   return {
      type: 'function',
      function: 'not',
      arguments: children,
      location: simpleLocation(location),
      text: text,
      serializeStyle: serializeStyle,
   }
 }
}

start
  = space? query:OrQuery space? {
    if (query.type === 'literal') {
      return buildAndQuery([query], location(), text(), 'implicit');
    }
    return query;
  }
  / whitespace:[\ \t\r\n]* {
    return {
      type: 'function',
      function: 'is',
      arguments: [ltoo('*')],
      location: simpleLocation(location()),
      text: text(),
      serializeStyle: 'operator',
    };
  }

OrQuery
  = left:AndQuery space+ 'or'i space+ right:OrQuery {
	  return {
      type: 'function',
      function: 'or',
      arguments: [left, right],
	    location: simpleLocation(location()),
      text: text(),
      serializeStyle: 'operator',
    };
  }
  / AndQuery

AndQuery
  = left:NegatedClause space+ 'and'i space+ right:AndQuery {
    return buildAndQuery([left, right], location(), text(), 'operator');
  }
  / left:NegatedClause space+ !'or' right:AndQuery {
    return buildAndQuery([left, right], location(), text(), 'implicit');
  }
  / NegatedClause

NegatedClause
  = [-] clause:Clause {
  	return buildNotQuery([clause], location(), text(), 'operator');
  }
  / Clause

Clause
  = '(' subQuery:start ')' {
    return subQuery;
  }
  / Term

Term
  = field:literal_arg_type ':' value:literal_arg_type {
    return {
      type: 'function',
      function: 'is',
      arguments: [field, value],
      location: simpleLocation(location()),
      text: text(),
      serializeStyle: 'operator',
    };
  }
  / field:literal_arg_type ':[' gt:literal_arg_type ' to 'i lt:literal_arg_type ']' {
    return {
      type: 'function',
      function: 'range',
      arguments: [field, gt, lt],
      location: simpleLocation(location()),
      text: text(),
      serializeStyle: 'shorthand',
    }
  }
  / function
  / literal_arg_type

function_name
 = first:[a-zA-Z]+ rest:[.a-zA-Z0-9_-]* { return first.join('') + rest.join('') }

function "function"
 = name:function_name space? '(' space? arg_list:arg_list? space? ')' {
  var result = {
    type: 'function',
    function: name,
    arguments: arg_list || [],
    location: simpleLocation(location()),
    text: text()
  }

  return result;
 }

arg_list
 = first:argument rest:(space? ',' space? arg:argument {return arg})* space? ','? {
  return [first].concat(rest);
 }

argument
 = name:function_name space? '=' space? value:arg_type {
  return {
   type: 'namedArg',
   name: name,
   value: value,
   location: simpleLocation(location()),
   text: text()
  }
 }
 / element:arg_type {return element}

arg_type
 = OrQuery
 / literal_arg_type

literal_arg_type
 = literal:literal {
  var result = ltoo(literal);
  result.location = simpleLocation(location()),
  result.text = text();
  return result;
 }

 /* ----- Core types ----- */

literal "literal"
  =  '"' chars:dq_char* '"' { return chars.join(''); } // double quoted string
  / "'" chars:sq_char* "'" { return chars.join(''); } // single quoted string
  / 'true'  { return true; } // unquoted literals from here down
  / 'false' { return false; }
  / 'null'  { return null; }
  / string:[^\[\]()"',:=\ \t]+ { // this also matches numbers via Number()
   var result = string.join('');
   // Sort of hacky, but PEG doesn't have backtracking so
   // a number rule is hard to read, and performs worse
   if (isNaN(Number(result))) return result;
   return Number(result)
  }

space
 = [\ \t\r\n]+

dq_char
  = "\\" sequence:('"' / "\\") { return sequence; }
  / [^"] // everything except "

sq_char
  = "\\" sequence:("'" / "\\") { return sequence; }
  / [^'] // everything except '

integer
 = digits:[0-9]+ {return parseInt(digits.join(''))}
