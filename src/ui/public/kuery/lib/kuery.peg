/*
 * Kuery parser
 */

/*
 * Initialization block
 */
{
  var nodeTypes = options.helpers.nodeTypes;

  if (options.includeMetadata === undefined) {
    options.includeMetadata = true;
  }

  function ltoo(literal) {
    return {type: 'literal', value: literal}
  }

  function addMeta(source, text, location) {
    if (options.includeMetadata) {
      return Object.assign(
        {},
        source,
        {
          text: text,
          location: simpleLocation(location),
        }
      );
    }

    return source;
  }

  function simpleLocation(location) {
    // Returns an object representing the position of the function within the expression,
    // demarcated by the position of its first character and last character. We calculate these values
    // using the offset because the expression could span multiple lines, and we don't want to deal
    // with column and line values.
    return {
      min: location.start.offset,
      max: location.end.offset
    }
  }

  function buildAndQuery(children, location, text, serializeStyle) {
    return {
      type: 'function',
      function: 'and',
      arguments: children,
      location: simpleLocation(location),
      text: text,
      serializeStyle: serializeStyle,
    }
  }

  function buildNotQuery(children, location, text, serializeStyle) {
    return {
      type: 'function',
      function: 'not',
      arguments: children,
      location: simpleLocation(location),
      text: text,
      serializeStyle: serializeStyle,
    }
  }
}

start
  = space? query:OrQuery space? {
    if (query.type === 'literal') {
      return buildAndQuery([query], location(), text(), 'implicit');
    }
    return query;
  }
  / whitespace:[\ \t\r\n]* {
    return addMeta(nodeTypes.function.buildNode('is', '*'), text(), location());
  }

OrQuery
  = left:AndQuery space 'or'i space right:OrQuery {
	  return {
      type: 'function',
      function: 'or',
      arguments: [left, right],
	    location: simpleLocation(location()),
      text: text(),
      serializeStyle: 'operator',
    };
  }
  / AndQuery

AndQuery
  = left:NegatedClause space 'and'i space right:AndQuery {
    return buildAndQuery([left, right], location(), text(), 'operator');
  }
  / left:NegatedClause space !'or' right:AndQuery {
    return buildAndQuery([left, right], location(), text(), 'implicit');
  }
  / NegatedClause

NegatedClause
  = [-] clause:Clause {
  	return buildNotQuery([clause], location(), text(), 'operator');
  }
  / Clause

Clause
  = '(' subQuery:start ')' {
    return subQuery;
  }
  / Term

Term
  = field:literal_arg_type ':' value:literal_arg_type {
    return {
      type: 'function',
      function: 'is',
      arguments: [field, value],
      location: simpleLocation(location()),
      text: text(),
      serializeStyle: 'operator',
    };
  }
  / field:literal_arg_type ':[' space? gt:literal_arg_type space 'to'i space lt:literal_arg_type space? ']' {
    return {
      type: 'function',
      function: 'range',
      arguments: [field, gt, lt],
      location: simpleLocation(location()),
      text: text(),
      serializeStyle: 'shorthand',
    }
  }
  / function
  / !Keywords literal:literal_arg_type { return literal; }

function_name
 = first:[a-zA-Z]+ rest:[.a-zA-Z0-9_-]* { return first.join('') + rest.join('') }

function "function"
 = name:function_name space? '(' space? arg_list:arg_list? space? ')' {
  var result = {
    type: 'function',
    function: name,
    arguments: arg_list || [],
    location: simpleLocation(location()),
    text: text()
  }

  return result;
 }

arg_list
 = first:argument rest:(space? ',' space? arg:argument {return arg})* space? ','? {
  return [first].concat(rest);
 }

argument
 = name:function_name space? '=' space? value:arg_type {
  return {
   type: 'namedArg',
   name: name,
   value: value,
   location: simpleLocation(location()),
   text: text()
  }
 }
 / element:arg_type {return element}

arg_type
 = OrQuery
 / literal_arg_type

literal_arg_type
 = literal:literal {
  var result = ltoo(literal);
  result.location = simpleLocation(location()),
  result.text = text();
  return result;
 }

Keywords
  = 'and' / 'or'

 /* ----- Core types ----- */

literal "literal"
  =  '"' chars:dq_char* '"' { return chars.join(''); } // double quoted string
  / "'" chars:sq_char* "'" { return chars.join(''); } // single quoted string
  / 'true'  { return true; } // unquoted literals from here down
  / 'false' { return false; }
  / 'null'  { return null; }
  / string:[^\[\]()"',:=\ \t]+ { // this also matches numbers via Number()
   var result = string.join('');
   // Sort of hacky, but PEG doesn't have backtracking so
   // a number rule is hard to read, and performs worse
   if (isNaN(Number(result))) return result;
   return Number(result)
  }

space
 = [\ \t\r\n]+

dq_char
  = "\\" sequence:('"' / "\\") { return sequence; }
  / [^"] // everything except "

sq_char
  = "\\" sequence:("'" / "\\") { return sequence; }
  / [^'] // everything except '

integer
 = digits:[0-9]+ {return parseInt(digits.join(''))}
