// Initialization block
{
  const { nodeTypes: { function: { buildNode }}} = options.helpers;
  const parseCursor = Boolean(options.parseCursor);

  function getCursor(chars, location) {
    const i = chars.findIndex(char => char.type === 'cursor');
    return {
      type: 'cursor',
      prefix: chars.slice(0, i).join(''),
      suffix: chars.slice(i + 1).join(''),
      start: location.start.offset,
      end: location.end.offset - '@kibana-cursor@'.length
    };
  }
}

start
  = OrQuery
  / EmptyQuery

EmptyQuery
  = Space* {
    return buildNode('and', []);
  }

OrQuery
  = head:AndQuery Or tail:OrQuery {
    const cursor = [head, tail].find(node => node.type === 'cursor');
    if (cursor) return cursor;
    return buildNode('or', [head, tail]);
  }
  / AndQuery

AndQuery
  = head:NotQuery And tail:AndQuery {
    const cursor = [head, tail].find(node => node.type === 'cursor');
    if (cursor) return cursor;
    return buildNode('and', [head, tail]);
  }
  / NotQuery

NotQuery
  = Not query:SubQuery {
    if (query.type === 'cursor') return query;
    return buildNode('not', query);
  }
  / SubQuery

SubQuery
  = '(' Space* query:OrQuery Space* ')' { return query; }
  / Expression

Expression
  = FieldListExpression
  / FieldRangeExpression
  / ValueExpression

FieldListExpression
  = field:Literal Space* ':' Space* list:SubList {
    function buildNodeWithField(field, list) {
      if (list.type === 'cursor') {
        return {
          ...list,
          field,
          suggest: ['values']
        };
      } else if (list.hasOwnProperty('and')) {
        return buildNode('and', list.and.map(node => buildNodeWithField(field, node)));
      } else if (list.hasOwnProperty('or')) {
        return buildNode('or', list.or.map(node => buildNodeWithField(field, node)));
      } else if (list.hasOwnProperty('not')) {
        return buildNode('not', buildNodeWithField(field, list.not));
      } else {
        return buildNode('is', field, list);
      }
    }
    return buildNodeWithField(field, list);
  }

FieldRangeExpression
  = field:Literal Space* operator:RangeOperator Space* value:Literal {
    return buildNode('range', field, { [operator]: value });
  }

ValueExpression
  = value:Literal {
    if (value.type === 'cursor') {
      const field = (value.prefix + value.suffix).trim();
      return {
        ...value,
        field,
        suggest: ['fields', 'operators']
      };
    }
    return buildNode('is', '*', value);
  }

OrList
  = head:AndList Or tail:OrList {
    const cursor = [head, tail].find(node => node.type === 'cursor');
    if (cursor) {
      return {
        ...cursor,
        suggest: ['values']
      };
    }
    return { or: [head, tail] };
  }
  / AndList

AndList
  = head:NotList And tail:AndList {
    const cursor = [head, tail].find(node => node.type === 'cursor');
    if (cursor) {
      return {
        ...cursor,
        suggest: ['values']
      };
    }
    return { and: [head, tail] };
  }
  / NotList

NotList
  = Not list:SubList {
    if (list.type === 'cursor') {
      return {
        ...list,
        suggest: ['values']
      };
    }
    return { not: list };
  }
  / SubList

SubList
  = '(' Space* list:OrList Space* ')' {
    if (list.type === 'cursor') {
      return {
        ...list,
        suggest: ['values']
      };
    }
    return list;
  }
  / Literal

Or
  = Space+ 'or'i Space+

And
  = Space+ 'and'i Space+

Not
  = 'not'i Space+

Literal
  = SingleQuotedString
  / DoubleQuotedString
  / UnquotedLiteral

SingleQuotedString
  = "'" chars:(Cursor / EscapedQuote / [^'])* "'" {
    if (chars.find(char => char.type === 'cursor')) {
      return getCursor(chars, location());
    }
    return chars.join('');
  }

DoubleQuotedString
  = '"' chars:(Cursor / EscapedQuote / [^"])* '"' {
    if (chars.find(char => char.type === 'cursor')) {
      return getCursor(chars, location());
    }
    return chars.join('');
  }

UnquotedLiteral
  = chars:(UnquotedCharacter)+ {
    if (chars.find(char => char.type === 'cursor')) {
      return getCursor(chars, location());
    }
    const sequence = chars.join('').trim();
    if (sequence === 'null') return null;
    if (sequence === 'true') return true;
    if (sequence === 'false') return false;
    const number = Number(sequence);
    return isNaN(number) ? sequence : number;
  }

EscapedQuote
  = '\\' quote:('"' / '"') { return quote; }

UnquotedCharacter
  = Cursor
  / EscapedSpecialCharacter
  / !Separator char:. { return char; }

EscapedSpecialCharacter
  = '\\' char:SpecialCharacter { return char; }

Separator
  = Keyword / SpecialCharacter

Keyword
  = Or / And / Not

SpecialCharacter
  = [():<>]

RangeOperator
  = '<=' { return 'lte'; }
  / '>=' { return 'gte'; }
  / '<' { return 'lt'; }
  / '>' { return 'gt'; }

Space
  = [\ \t\r\n]

Cursor
  = &{ return parseCursor; } '@kibana-cursor@' {
    return { type: 'cursor' };
  }
