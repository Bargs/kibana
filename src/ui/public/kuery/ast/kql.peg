// Initialization block
{
  var { nodeTypes: { function: { buildNode }}} = options.helpers;
}

start
  = OrQuery
  / EmptyQuery

EmptyQuery
  = Space* {
    return buildNode('and', []);
  }

OrQuery
  = left:AndQuery Or right:OrQuery {
    return buildNode('or', [left, right]);
  }
  / AndQuery

AndQuery
  = left:NotQuery And right:AndQuery{
    return buildNode('and', [left, right]);
  }
  / NotQuery

NotQuery
  = Not query:SubQuery {
    return buildNode('not', query);
  }
  / SubQuery

SubQuery
  = '(' Space* query:OrQuery Space* ')' { return query; }
  / Expression

Expression
  = FieldListExpression
  / FieldRangeExpression
  / ValueExpression

FieldListExpression
  = field:Literal Space* ':' Space* list:SubList {
    function buildNodeWithField(node) {
      if (node.hasOwnProperty('arguments')) {
        const args = node.arguments.map(buildNodeWithField);
        return { ...list, arguments: args };
      } else {
        if (Arrays.isArray(node)) {
          const isNodes = node.map((value) => {
            return buildNode('is', field, value);
          }
          return buildNode('or', isNodes);
        }

        return buildNode('is', field, node);
      }
    }
    return buildNodeWithField(list);
  }

FieldRangeExpression
  = field:Literal Space* operator:RangeOperator Space* value:Literal {
    return buildNode('range', field, { [operator]: value });
  }

ValueExpression
  = value:Literal {
    return buildNode('is', null, value);
  }
  // add support for wildcards here

OrList
  = left:AndList Or right:OrList {
    return buildNode('or', [left, right]);
  }
  / AndList

AndList
  = left:NotList And right:AndList{
    return buildNode('and', [left, right]);
  }
  / NotList

NotList
  = Not list:SubList {
    return buildNode('not', query);;
  }
  / SubList

SubList
  = '(' Space* list:OrList Space* ')' { return list; }
  / WildcardExpression
  / Literal

WildcardExpression
  = head:UnquotedLiteral? wildcardLiteral:WildcardLiteral tail:FieldListValueExpression? {
    return [head, wildcardLiteral, ...tail];
  }

Or
  = Space+ 'or'i Space+

And
  = Space+ 'and'i Space+

Not
  = 'not'i Space+

WildcardLiteral
  = prefix:UnquotedLiteral? "*" suffix:UnquotedLiteral? {
    return text();
  }

Literal
  = SingleQuotedString
  / DoubleQuotedString
  / UnquotedLiteral

SingleQuotedString
  = "'" chars:(EscapedQuote / [^'])* "'" {
    return chars.join('');
  }

DoubleQuotedString
  = '"' chars:(EscapedQuote / [^"])* '"' {
    return chars.join('');
  }

UnquotedLiteral
  = chars:UnquotedCharacter+ {
    const sequence = chars.join('').trim();
    if (sequence === 'null') return null;
    if (sequence === 'true') return true;
    if (sequence === 'false') return false;
    const number = Number(sequence);
    return isNaN(number) ? sequence : number;
  }

EscapedQuote
  = '\\' quote:('"' / "'") { return quote; }

UnquotedCharacter
  = EscapedSpecialCharacter
  / !Separator char:. { return char; }

EscapedSpecialCharacter
  = '\\' char:SpecialCharacter { return char; }

Separator
  = Keyword / SpecialCharacter

Keyword
  = Or / And / Not

SpecialCharacter
  = [():<>]

RangeOperator
  = '<=' { return 'lte'; }
  / '>=' { return 'gte'; }
  / '<' { return 'lt'; }
  / '>' { return 'gt'; }

Space
  = [\ \t\r\n]
